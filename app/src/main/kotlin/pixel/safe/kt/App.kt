/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package pixel.safe.kt

import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.required

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

enum class Mode(val title: String) {
    ENCRYPT("encrypt"),
    DECRYPT("decrypt")
}

fun main(args: Array<String>) {
    println(App().greeting)
    val parser = ArgParser("pixel-safe-kt")
    val mode by parser.option(
        ArgType.String,
        shortName = "m",
        description = "The mode to run the application (encrypt or decrypt or generate)"
    ).required()
    val code by parser.option(
        ArgType.String,
        shortName = "c",
        description = "___"
    ).required()
    val fileToCrypt by parser.option(
        ArgType.String,
        shortName = "f",
        description = "___"
    ).required()
    val outputFile by parser.option(
        ArgType.String,
        shortName = "o",
        description = "___"
    ).required()

    parser.parse(args)

    println("Mode -> ${convertModeStringToMode(mode).title}")
    println("Code -> ${code}")
    println("File to crypt -> ${fileToCrypt}")
    println("Output File to put intp -> ${outputFile}")
    // 954356 - RGBRGB

//    ImageDrawer.addPixelsToExistingImage()
//    if (!KeyManager.checkIfKeyFileExists()) {
//        KeyManager.generateKeyFile()
//    }
//    ImageDrawer.drawToFile("test4")

    when (convertModeStringToMode(mode)) {
        Mode.DECRYPT -> {

            val enc = Decrypter()
            val out = enc.crypt(FileManager.getFile(fileToCrypt), code)
            println("RESULT: ---> ")
            println(out)

        }
        Mode.ENCRYPT -> {
            val enc = Encrypter()
            val b = FileManager.readFileToCharArray(FileManager.getFile(fileToCrypt))
            if (b != null) {
                enc.crypt(b, code, outputFile)
            }
        }
    }

}

fun convertModeStringToMode(modeStr: String): Mode {
    return when (modeStr) {
        "e" -> {
            Mode.ENCRYPT
        }
        else -> {
            Mode.DECRYPT
        }
    }
}

/*

BufferedImage
        BufferedImage bfImg = new BufferedImage(actualWidth,actualHeight,BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = bfImg.createGraphics();


        try{
            File filenew = new File(fileOut+".png");
            ImageIO.write(bfImg,"png",filenew);
        } catch(IOException e){
            System.out.println("Problem writing to files");
        }

    val parser = ArgParser("example")
    val input by parser.option(ArgType.String, shortName = "i", description = "Input file").required()
    val output by parser.option(ArgType.String, shortName = "o", description = "Output file name")
    val format by parser.option(ArgType.Choice<Format>(), shortName = "f",
    	description = "Format for output file").default(Format.CSV).multiple()
    val stringFormat by parser.option(ArgType.Choice(listOf("html", "csv", "pdf"), { it }), shortName = "sf",
        description = "Format as string for output file").default("csv").multiple()
    val debug by parser.option(ArgType.Boolean, shortName = "d", description = "Turn on debug mode").default(false)
    val eps by parser.option(ArgType.Double, description = "Observational error").default(0.01)

    parser.parse(args)
    val inputData = readFrom(input)
    val result = calculate(inputData, eps, debug)


      options.addOption("m", "mode", true, "The mode to run the application (encrypt or decrypt or generate)")
                .addOption("f", "file", true, "The file to decrypt from or encrypt to depending on the mode")
                .addOption("o","fileOut", true , "The file name to create")
                .addOption("k","key",true,"JSON File containing the channel pattern to encrypt with")
                .addOption("h","help", false , "Help for this program")
                .addOption("c", "channel", true, "Channel to encrypt into or read from (R, G or B)");
 */